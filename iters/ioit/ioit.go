// Copyright (c) 2023 individual contributors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <https://www.apache.org/licenses/LICENSE-2.0>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ioit

import (
	"errors"
	"sync/atomic"

	"github.com/0x5a17ed/coro"
	"github.com/0x5a17ed/itkit"
)

var (
	ErrStopped = errors.New("stopped")
)

// YieldFn is a function that is called by a generator to send back
// values generated by the same generator.
//
// The return value of YieldFn indicates whenever the generator was
// closed (false) or the generator is allowed to continue (true).
type YieldFn[O any] func(O) bool

// GeneratorFn is a function that generates values which are sent back
// through the given [YieldFn] yield function.
//
// The cont parameter tells the generator whenever it is allowed to
// continue or not.  The argument must be evaluated at the beginning
// of the generator before any call to yield.  The generator must
// return before any call to yield if the argument evaluates to false.
//
// See [YieldFn] for the documentation of the yield argument.
type GeneratorFn[O any] func(cont bool, yield func(O) bool) error

type Generator[T any] struct {
	*coro.C[bool, T]

	value T
	err   atomic.Pointer[error]
}

// Next fetches the next value produced by the wrapped [GeneratorFn]
// and returns true whenever there is a new value available and false
// otherwise.
func (g *Generator[T]) Next() (ok bool) {
	g.value, ok = g.Resume(true)
	return
}

// Value returns the latest value produced by the wrapped [GeneratorFn].
func (g *Generator[T]) Value() T { return g.value }

// Iter returns the [Generator] as an [itkit.Iterator] value.
func (g *Generator[T]) Iter() itkit.Iterator[T] {
	return g
}

// Close signals the generator to close down and returns any error returned by
// the [GeneratorFn] function.
func (g *Generator[T]) Close() error {
	var ok bool
	if g.value, ok = g.Resume(false); ok {
		// The generator had its chance.
		g.C.Stop()
	}
	return g.Err()
}

// Err returns any error returned by the [GeneratorFn] function.
func (g *Generator[T]) Err() error {
	if err := g.err.Load(); err != nil {
		return *err
	}
	return nil
}

func Run[T any](fn GeneratorFn[T]) *Generator[T] {
	iog := &Generator[T]{}

	iog.C = coro.NewSub[bool, T](func(cont bool, yield func(T) bool) {
		defer func() {
			if errP := iog.err.Load(); errP != nil {
				return
			}
			// No err value stored means fn run into a panic.
			r := recover()

			if coro.IsStopped(r) {
				// Generator was stopped, pass that value down.
				err := ErrStopped
				iog.err.Store(&err)
			}

			// Propagate the panic value in any case.
			panic(r)
		}()

		err := fn(cont, yield)
		iog.err.Store(&err)
	})

	return iog
}
